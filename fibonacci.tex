\section{Algorytm macierzowy wyznaczania liczb Fibonacciego}

W tym rozdziale opiszemy algorytm obliczania liczb Fibonacciego, który wykorzystuje szybkie 
potęgowanie\footnote{\url{https://en.wikipedia.org/wiki/Exponentiation_by_squaring}}. 
Algorytm działa w czasie $O(\log{n})$, co sprawia, że jest znacznie atrakcyjniejszy od algorytmu 
dynamicznego, który wymaga czasu $O(n)$.

Znajdźmy taką macierz $M$, która po wymnożeniu przez transponowany wektor wyrazów 
$F_{n}$ i $F_{n - 1}$ da nam wektor, w którym otrzymamy wyrazy $F_{n + 1}$ oraz $F_{n}$. 
Łatwo sprawdzić, że dla ciągu Fibonacciego taka macierz ma postać:


\begin{equation}
	M = \begin{bmatrix}1 & 1\\1 & 0\end{bmatrix}
\end{equation}
Bo:
\begin{equation}
\label{eq:fibonacci_m}
	M \times
	\begin{bmatrix}F_n \\ F_{n - 1}\end{bmatrix}
	= \begin{bmatrix}F_{n + 1} \\ F_{n}\end{bmatrix}
\end{equation}

Wynika to wprost z definicji mnożenia macierzy oraz definicji ciągu Fibonacciego.


\begin{observation}{Zauważmy, że możemy $M$ przemnożyć przez macierz otrzymaną w \ref{eq:fibonacci_m}. Otrzymamy wtedy macierz postaci:}
\begin{equation}
	M \times (M \times \begin{bmatrix}F_n \\ F_{n - 1}\end{bmatrix})
\end{equation}
\end{observation}

\begin{observation}{A gdy zrobimy to $n$ razy...}
\label{obs:mult-n-times}
\begin{equation}
	M \times (M \times (M \times ...\, (M \times \begin{bmatrix}F_n \\ F_{n - 1}\end{bmatrix})\,...\,))
\end{equation}
\end{observation}

\begin{fact}{Mnożenie macierzy jest łączne.}
\label{fact:mult-is-associative}
\end{fact}

Z Faktu \ref{fact:mult-is-associative}. i Obserwacji \ref{obs:mult-n-times}. mamy:

\begin{equation}
	M^n \times \begin{bmatrix}F_n \\ F_{n - 1}\end{bmatrix}
\end{equation}

Pokażemy, że powyższa macierz ma zastosowanie w obliczaniu n-tej liczby Fibonacciego.

\begin{lemma}
\begin{equation}
	M^{n} \times \begin{bmatrix}F_1 \\ F_0\end{bmatrix} = \begin{bmatrix}F_{n + 1} \\ F_{n}\end{bmatrix}
\end{equation}
\end{lemma}

\begin{proof}{Przez indukcję.}\\
Sprawdźmy dla $n = 1$. Mamy:
\begin{equation}
	\begin{bmatrix}1 & 1\\1 & 0\end{bmatrix}^1 \times \begin{bmatrix}1 \\ 0\end{bmatrix}
	= \begin{bmatrix}1 \\ 1\end{bmatrix} = \begin{bmatrix}F_2 \\ F_1\end{bmatrix}
\end{equation}

Rozważmy $n + 1$ zakładając poprawność dla $n$.

\begin{equation}
	\begin{bmatrix}1 & 1\\1 & 0\end{bmatrix}^{n + 1} \times \begin{bmatrix}1 \\ 0\end{bmatrix}
	= \begin{bmatrix}1 & 1\\1 & 0\end{bmatrix} \times \begin{bmatrix}1 & 1\\1 & 0\end{bmatrix}^{n} \times \begin{bmatrix}1 \\ 0\end{bmatrix}
	= \begin{bmatrix}1 & 1\\1 & 0\end{bmatrix} \times \begin{bmatrix}F_{n+1} \\ F_{n}\end{bmatrix}
	\stackrel{\ref{eq:fibonacci_m}}{=} \begin{bmatrix}F_{n + 2} \\ F_{n + 1}\end{bmatrix}
\end{equation}
\end{proof}

\begin{algorithm}[h]
	\DontPrintSemicolon
	\SetAlgorithmName{Algorytm}{}
	
	\KwData{ n }
	
	\KwResult{ $n+1$-sza liczba Fibonacciego }

	$M \leftarrow \begin{bmatrix}1 & 1\\1 & 0\end{bmatrix}$\;
	$M' \leftarrow \texttt{exp\_by\_squaring(M, n)}$\;
	
	\KwRet{$\texttt{pierwszy element wektora}\,(M' \times \begin{bmatrix}1 \\ 0\end{bmatrix})$}\;

	\caption{Procedura \texttt{get\_fibonacci}}
\end{algorithm}

Mimo że powyższy algorytm działa w czasie $O(\log{n})$, warto mieć na uwadze fakt, że liczby Fibonacciego 
rosną wykładniczo. W praktyce oznacza to pracę na liczbach przekraczających długość słowa maszynowego.

Zaprezentowaną metodę można uogólnić na dowolne ciągi, które zdefiniowane są przez liniową 
kombinację skończonej liczby poprzednich elementów. Wystarczy znaleźć odpowiednią macierz $M$; 
dla ciągów postaci $G_{n + 1} = a_n G_n + a_{n - 1} G_{n - 1} + ... + a_{n - k} G_{n - k}$ jest to:
\begin{equation}
	M = \begin{bmatrix}a_n    & a_{n - 1} & a_{n - 2} & \dots & a_{n - k} & a_{n - k}\\
	                   1      & 0         & 0         & \dots & 0 & 0 \\
	                   0      & 1         & 0         & \dots & 0 & 0\\
	                   0      & 0         & \ddots\\
	                   \vdots &           &           & \ddots\\
	                   0      & 0         & 0         & \dots & 1 & 0
	    \end{bmatrix}
\end{equation}

Dowód tej konstrukcji pozostawiamy czytelnikowi jako ćwiczenie.
